# ATP_S2_LB3
## Контрольные вопросы
<details><summary>1. Какие основные элементы включает стандартная библиотека C ++?</summary>
   Библиотека включает в себя следующие компоненты:

+ средства для работы с потоками ввода / вывода;
+ набор структурированных данных и алгоритмов, ранее известных как стандартная библиотека шаблонов (Standard Template Library, STL)
+ средства локализации (адаптации к национальным языкам)
+ параметризованный класс string;
+ параметризованный класс complex для представления комплексных величин;
+ класс vallaray, оптимизированный для обработки числовых массивов;
+ параметризованный класс numeric_limits и специализации для каждого базового типа данных;
+ средства управления памятью;
+ большая поддержка национальных наборов символов;
+ средства обработки исключений.
</details>
<details><summary>2. Что такое контейнер Стандартной библиотеки?</summary>

Контейнер - это класс, который хранит коллекцию других объектов и включает базовые функции для поддержки использования общих алгоритмов. Стандартные контейнеры не являющиеся производными от некоторого общего базового класса. Вместо этого каждый контейнер обеспечивает набор стандартных операций со стандартными именами и смыслом.

Есть основные группы контейнеров:

+ последовательности - вектор (vector), список (list), дек (deque, очередь о двух концах)
+ адаптеры последовательностей - стек (stack), очередь (queue), очередь с приоритетом (priority_queue)
+ ассоциативные контейнеры - ассоциативные массивы (map, multimap) и множественного числа (set, multiset).

</details>
<details><summary>3. Чем отличаются последовательные и ассоциативные контейнеры?</summary>
   
+ Последовательные контейнеры реализуют структуры данных с возможностью последовательного доступа к ним.
+ Ассоциативные контейнеры реализуют упорядоченные структуры данных с возможностью быстрого поиска (со сложностью O(log n)).
+ Неупорядоченные ассоциативные контейнеры реализуют неупорядоченные (хешированные) структуры данных с возможностью быстрого поиска (со средней сложностью O(1), в худшем случае O(n)).((начиная с C++11) unordered_set, unordered_map, unordered_multiset)
+ Адаптеры контейнеров предоставляют различные интерфейсы для последовательных контейнеров.


</details>
<details><summary>4. Что такое итератор?</summary>
   
Итератор - это объект, который абстрагирует понятие указателя на элемент последовательности и позволяет обходить элементы последовательности в определенном направлении.
</details>
<details><summary>5. Какие требования предъявляются к итераторов Стандартной библиотеки?</summary>
   
Объект-итератор должен поддерживать следующие операции:

+ получения текущего элемента (реализовано операторами * и ->)
+ инкремент (реализовано оператором ++)
+ проверка на равенство (реализовано оператором ==)
</details>
<details><summary>6. В чем преимущества вектора по сравнению с массивом?</summary>
   
Преимущества вектора в том что он автоматически увеличивается, при нехватки места.
</details>
<details><summary>7. Какие есть стандартные классы для представления множества?</summary>

set, он реализует такие сущности как множество и мультимножество. По сути это контейнеры, которые содержат некоторое количество отсортированных элементов. При добавлении нового элемента в множество он сразу становится на свое место так, чтобы не нарушать порядка сортировки. 
</details>

<details><summary>8. Что такое алгоритм Стандартной библиотеки?</summary>

Алгоритм - функции для различных целей (напр., поиска, сортировки, подсчета, манипулирования), оперирующие над диапазонами элементов. Обратите внимание, что диапазон определяется как [first, last), где last относится к элементу, следующему за последним просматриваемым или изменяемым элементом.
</details>
<details><summary>9. Какие группы алгоритмов?</summary>
Все алгоритмы https://ru.cppreference.com/w/cpp/algorithm
Группы алгоритмов:
+ Немодифицирующие операции над последовательностями
+ Модифицирующие операции над последовательностями
+ Операции разделения
+ Операции сортировки (на отсортированных диапазонах)
+ Операции двоичного поиска (на отсортированных диапазонах)
+ Прочие операции на отсортированных диапазонах
+ Операции над множествами (на отсортированных диапазонах)
+ Операции над кучей
+ Операции минимума/максимума
+ Операции сравнения
+ Операции перестановки
+ Числовые операции
+ Операции над неинициализированной памятью
</details>
<details><summary>10. Как алгоритм связан с типом контейнера, к которому он применяется?</summary>

Связан через итератор
</details>
<details><summary>11. Что такое функциональный объект?</summary>

Функциональный объект - это любой объект для которого определён оператор вызова функции. C++ предоставляет множество встроенных функциональных объектов, а также поддерживает создание и манипуляцию новыми функциональными объектами.
</details>
<details><summary>12. Что такое функция-предикат? Какие стандартные функции-предикаты?</summary>

Предикаты- подмножество функторов, в которых тип возвращаемого значения operator() bool.
</details>
<details><summary>13. Что такое адаптеры функций?</summary>

Адаптеры – это специальные классы, разбитые на следующие две категории:

* связыватели (binders). Это адаптеры, преобразующие бинарный объект-функцию в унарный объект, связывая один из аргументов с конкретным значением. Например, для подсчета в контейнере всех элементов, которые меньше или равны 10, следует передать алгоритму count_if() объект-функцию less_equal, один из аргументов которого равен 10. В следующем разделе мы покажем, как это сделать;

* отрицатели (negators). Это адаптеры, изменяющие значение истинности объекта-функции на противоположное. Например, для подсчета всех элементов внутри контейнера, которые больше 10, мы могли бы передать алгоритму count_if() отрицатель объекта-функции less_equal, один из аргументов которого равен 10. Конечно, в данном случае проще передать связыватель объекта-функции greater, ограничив один из аргументов со значением 10.
</details>
<details><summary>14. Какие новые возможности предоставляет стандарт C ++ 11</summary>

+ Списки инициализации
+ Автоматическое определение типов
+ Цикл for, построенный на диапазоне
+ Лямбда-функции и выражения
+ Альтернативный синтаксис функций
Возможность вызова конструкторов из других конструкторов в списке инициализации
+ Явное переопределение виртуальных функций (модификатор override после заголовка переопределены функции)
+ Константа для нулевого указателя nullptr
+ Строго типизированные перечисления
+ Локальные и безымянные типы в качестве аргументов шаблонов
+ Символы и строки в Unicode
+ "Сырые" строки (Raw string literals)
+ Создание возможности реализации уборка мусора
</details>
<details><summary>15. Что такое список инициализации?</summary>
   
Традиционно списки инициализации используют для инициализации массивов и структур.Расширение возможностей списков инициализации связано с шаблонным классом std :: initializer_list. Объекты соответствующего типа является неявными константами.
</details>
<details><summary>16. Что такое автоматическое определение типов?</summary>

Механизм автоматического определения типов позволяет компилятору создавать локальные переменные, тип которых зависит от контекста. Такие переменные обязательно должны быть инициализированы. Тип переменной компилятор определяет в соответствии с типом выражения, которым эта переменная инициализируется.
</details>
<details><summary>18. Какие есть способы использования лямбда-выражений?</summary>

Лямбда-выражения могут быть использованы везде, где требуется указатель на функцию.
</details>
